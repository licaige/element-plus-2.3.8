/* Element CSS BEM 相关函数 */
@use 'function' as *;
@use '../common/var' as *;
// forward mixins
@forward 'config';
@forward 'function';
@forward '_var';
@use 'config' as *;

// Break-points
@mixin res($key, $map: $breakpoints) {
  // loop breakpoint Map, return if present
  @if map-has-key($map, $key) {
    @media only screen and #{unquote(map-get($map, $key))} {
      @content;
    }
  } @else {
    @warn "Undefined points: `#{$map}`";
  }
}

// Scrollbar
@mixin scroll-bar {
  $scrollbar-thumb-background: getCssVar('text-color', 'disabled');
  $scrollbar-track-background: getCssVar('fill-color', 'blank');

  &::-webkit-scrollbar {
    z-index: 11;
    width: 6px;

    &:horizontal {
      height: 6px;
    }

    &-thumb {
      border-radius: 5px;
      width: 6px;
      background: $scrollbar-thumb-background;
    }

    &-corner {
      background: $scrollbar-track-background;
    }

    &-track {
      background: $scrollbar-track-background;

      &-piece {
        background: $scrollbar-track-background;
        width: 6px;
      }
    }
  }
}
//BEM
// Block（块）、Element（元素）、Modifier（修饰符）
// BEM命名规则
// 块名称为其元素和修饰符定义了命名空间。
// 块名称与元素名称之间用双连字符--分隔。
// 块名称与修饰符或元素与修饰符之间用双下划线__分隔。
// 命名一般使用小写字母。
// 单词之间可以使用-分隔。
// 命名约定的模式有如下几种：

// .block{}
// .block__element{}
// .block--modifier{}
// .block__element{}--modifier{}

//.tp-button{}


// BEM
@mixin b($block) {
  // !global 将局部变量转为全局变量
  $B: $namespace + $common-separator + $block !global;//.el-button{}
  .#{$B} {
    @content;
  }
}
/*
$B 表示定义一个一个变量，$namespace 是来自 config.scss 文件中定义的变量，
!global 表示其是一个全局变量，这样就可以在整个文件的任意地方使用。
#{} 字符串插值，类似模板语法。
通过 @content 可以将 include{} 中传递过来的内容导入到指定位置。
*/
// &__header  => .tp-button__header
//定义 Element
@mixin e($element) {
  /*
 首先定义一个全局变量 $E，接着定义父选择器 $selector，再定义当前的选择器 $currentSelector，再通过循环得到当前的选择器。
 */
  $E: $element !global;
  $selector: &; // & 表示父类选择器
  $currentSelector: '';
  @each $unit in $element {
    $currentSelector: #{$currentSelector +
      '.' +
      $B +
      $element-separator +
      $unit +
      ','};
  }
/*
接着通过函数 hitAllSpecialNestRule（hitAllSpecialNestRule 函数在 mixins 目录的 function.scss 文件中）
 判断父选择器是否含有 Modifier、表示状态的.is- 和 伪类，如果有则表示需要嵌套。
  判断是否存在特殊嵌套 包含修饰器，包含状态 包含伪类
*/
  @if hitAllSpecialNestRule($selector) {
    // 如果 包含修饰器 状态 或者 伪类 则
    // 返回 与父类同级
    @at-root {
      #{$selector} {
        #{$currentSelector} {
          @content;
        }
      }
    }
  } @else {
    /*
     @at-root 的作用就是将处于其内部的代码提升至文档的根部，即不对其内部代码使用嵌套。
    */
    @at-root {
      #{$currentSelector} {
        @content;
      }
    }
  }
}
// &--primary => .tp-button--primary
//定义修改器
@mixin m($modifier) {
  /*
  定义了父选择器变量 $selector 和 当前选择器变量 $currentSelector，
  并且当前选择器变量初始值为空，再通过循环传递进来的参数 $modifier，
  获得当前选择器变量 $currentSelector 的值，再定义样式内容，
  而样式内容是通过 @content 将 include{} 中传递过来的内容
  */
  $selector: &;
  $currentSelector: '';
  @each $unit in $modifier {
    $currentSelector: #{$currentSelector +
      $selector +
      $modifier-separator +
      $unit +
      ','};
  }

  @at-root {
    #{$currentSelector} {
      @content;
    }
  }
}

@mixin configurable-m($modifier, $E-flag: false) {
  $selector: &;
  $interpolation: '';

  @if $E-flag {
    $interpolation: $element-separator + $E-flag;
  }

  @at-root {
    #{$selector} {
      .#{$B + $interpolation + $modifier-separator + $modifier} {
        @content;
      }
    }
  }
}

@mixin spec-selector(
  $specSelector: '',
  $element: $E,
  $modifier: false,
  $block: $B
) {
  $modifierCombo: '';

  @if $modifier {
    $modifierCombo: $modifier-separator + $modifier;
  }

  @at-root {
    #{&}#{$specSelector}.#{$block
      + $element-separator
      + $element
      + $modifierCombo} {
      @content;
    }
  }
}

@mixin meb($modifier: false, $element: $E, $block: $B) {
  $selector: &;
  $modifierCombo: '';

  @if $modifier {
    $modifierCombo: $modifier-separator + $modifier;
  }

  @at-root {
    #{$selector} {
      .#{$block + $element-separator + $element + $modifierCombo} {
        @content;
      }
    }
  }
}
//定义动作状态
@mixin when($state) {
  /*
  选择器就是 config.scss 文件中的变量 $state-prefix 加传进来的状态变量，而样式内容是通过 @content 将 include{} 中传递过来的内容
  */
  @at-root {
    &.#{$state-prefix + $state} {
      @content;
    }
  }
}

@mixin extend-rule($name) {
  @extend #{'%shared-' + $name} !optional;
}

@mixin share-rule($name) {
  $rule-name: '%shared-' + $name;

  @at-root #{$rule-name} {
    @content;
  }
}

@mixin pseudo($pseudo) {
  @at-root #{&}#{':#{$pseudo}'} {
    @content;
  }
}

@mixin picker-popper($background, $border, $box-shadow) {
  &.#{$namespace}-popper {
    background: $background;
    border: $border;
    box-shadow: $box-shadow;

    .#{$namespace}-popper__arrow {
      &::before {
        border: $border;
      }
    }

    @each $placement,
      $adjacency
        in ('top': 'left', 'bottom': 'right', 'left': 'bottom', 'right': 'top')
    {
      &[data-popper-placement^='#{$placement}'] {
        .#{$namespace}-popper__arrow::before {
          border-#{$placement}-color: transparent;
          border-#{$adjacency}-color: transparent;
        }
      }
    }
  }
}

// dark
@mixin dark($block) {
  html.dark {
    @include b($block) {
      @content;
    }
  }
}

@mixin inset-input-border($color, $important: false) {
  @if $important == true {
    box-shadow: 0 0 0 1px $color inset !important;
  } @else {
    box-shadow: 0 0 0 1px $color inset;
  }
}
